<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D FPS — Fixed: Cursor Lock, Movement, Minecraft Hands (Three.js)</title>
  <style>
    html,body{height:100%;margin:0;background:#071726;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
    #container{width:100%;height:100%}
    .crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:6px;height:6px;border-radius:50%;background:#fff;pointer-events:none;z-index:40}
    .hud{position:fixed;left:12px;bottom:12px;color:#fff;font-size:13px;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:6px;z-index:40}
    .info{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:40;color:#fff;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:6px}
    .startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:41;padding:10px 14px;border-radius:8px;background:#7df;color:#002;cursor:pointer}
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="crosshair"></div>
  <div class="hud">Weapon: <strong id="weaponName">AK-47</strong> • Ammo: <span id="ammo">30</span>/<span id="reserve">90</span></div>
  <div class="info" id="infoText">Click to lock pointer — WASD move, Mouse look, LMB fire, 1/2/3 switch, R reload</div>
  <div id="startBtn" class="startBtn">Click to start (required)</div>

  <!-- Non-module Three.js build + PointerLockControls for best compatibility on GitHub Pages -->
  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.154.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
  (function(){
    const startBtn = document.getElementById('startBtn');
    const infoText = document.getElementById('infoText');

    if(typeof THREE === 'undefined'){
      infoText.textContent = 'Three.js failed to load. Check network or CDN.';
      return;
    }

    // ---------- Scene / Camera / Renderer ----------
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x071726, 0.0025);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 1000);
    camera.position.set(0, 1.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // ---------- Lights (improved) ----------
    const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
    const hemi = new THREE.HemisphereLight(0xddeeff, 0x444455, 0.6); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(10,20,10); sun.castShadow = true; sun.shadow.mapSize.set(2048,2048); scene.add(sun);
    const warm = new THREE.PointLight(0xffe6c7, 0.4, 30); warm.position.set(-6,4,-6); scene.add(warm);

    // ---------- Ground & environment ----------
    const floorMat = new THREE.MeshStandardMaterial({ color:0x6a7b3e, roughness:0.95 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(400,400), floorMat); floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

    const crateGeo = new THREE.BoxGeometry(1.4,1.4,1.4);
    for(let i=0;i<20;i++){
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.03 + Math.random()*0.08, 0.6, 0.25), roughness:0.7 });
      const crate = new THREE.Mesh(crateGeo, mat); crate.position.set((Math.random()-0.5)*60, 0.7, -5 - Math.random()*60); crate.castShadow = true; crate.receiveShadow = true; scene.add(crate);
    }

    // ---------- Hands (Minecraft-style blocky arms) ----------
    // We'll create two blocky arms that are clearly visible in first-person.
    const hands = new THREE.Group(); camera.add(hands); hands.position.set(0, -0.25, -0.45);

    function makeMinecraftArm(side = 'left'){
      const arm = new THREE.Group();
      // shoulder / upper arm
      const upper = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.5, 0.18), new THREE.MeshStandardMaterial({ color: 0xffd1a4 }));
      upper.position.set(side==='left' ? -0.28 : 0.28, -0.15, 0);
      // lower arm / hand
      const lower = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.28, 0.16), new THREE.MeshStandardMaterial({ color: 0xffd1a4 }));
      lower.position.set(side==='left' ? -0.28 : 0.28, -0.42, -0.03);
      arm.add(upper); arm.add(lower);
      // simple sleeve
      const sleeve = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.06,0.2), new THREE.MeshStandardMaterial({ color: 0x3333aa }));
      sleeve.position.set(side==='left' ? -0.28 : 0.28, -0.03, 0);
      arm.add(sleeve);
      arm.traverse(m => { if(m.isMesh){ m.castShadow = false; m.frustumCulled = false; } });
      return arm;
    }

    const leftArm = makeMinecraftArm('left'); const rightArm = makeMinecraftArm('right');
    hands.add(leftArm); hands.add(rightArm);

    // ---------- Weapons (simple but visible models) ----------
    function makeAK(){
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.12,0.12), new THREE.MeshStandardMaterial({ color:0x1b1b1b, metalness:0.6, roughness:0.35 })); body.position.set(0.15,-0.02,0); g.add(body);
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.8,10), new THREE.MeshStandardMaterial({ color:0x0b0b0b, metalness:1.0 })); barrel.rotation.z = Math.PI/2; barrel.position.set(0.6,-0.02,0); g.add(barrel);
      const stock = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.1,0.12), new THREE.MeshStandardMaterial({ color:0x3b2a22 })); stock.position.set(-0.6,0,-0.02); g.add(stock);
      g.name='AK-47'; g.userData.anim = { recoil:0 }; g.traverse(m=>{ if(m.isMesh){ m.frustumCulled = false; m.castShadow = false; } });
      return g;
    }
    function makeGlock(){
      const g = new THREE.Group();
      const slide = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.08,0.12), new THREE.MeshStandardMaterial({ color:0x333333, metalness:0.6 })); slide.position.set(0.15,-0.02,0); g.add(slide);
      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.32,0.08), new THREE.MeshStandardMaterial({ color:0x091018, roughness:0.95 })); grip.position.set(-0.12,-0.18,0); grip.rotation.z = -0.05; g.add(grip);
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.35,8), new THREE.MeshStandardMaterial({ color:0x0b0b0b })); barrel.rotation.z = Math.PI/2; barrel.position.set(0.42,-0.02,0); g.add(barrel);
      g.name = 'Glock 19'; g.userData.anim = { recoil:0 }; g.traverse(m=>{ if(m.isMesh){ m.frustumCulled = false; } });
      return g;
    }
    function makeKnife(){
      const g = new THREE.Group();
      const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.3,0.02), new THREE.MeshStandardMaterial({ color:0xcfcfcf, metalness:0.95 })); blade.position.set(0.25,-0.05,0); blade.rotation.z = 0.25; g.add(blade);
      const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.09,0.05), new THREE.MeshStandardMaterial({ color:0x2b1a0f })); handle.position.set(-0.02,-0.12,0); g.add(handle);
      g.name='Knife'; g.userData.anim = { swing:0 }; g.traverse(m=>{ if(m.isMesh){ m.frustumCulled = false; } }); g.scale.set(1.4,1.4,1.4);
      return g;
    }

    const weapons = [makeAK(), makeGlock(), makeKnife()];
    weapons.forEach((w)=>{ w.position.set(0.25, -0.12, -0.2); w.rotation.set(-0.15, 0.2, 0); hands.add(w); w.visible = true; w.renderOrder = 999; });

    let activeWeapon = 0; // default to AK
    function setActive(i){ weapons.forEach((w, idx)=> w.visible = (idx === i)); activeWeapon = i; updateHUD(); }
    setActive(0);

    // ---------- Weapon & HUD data ----------
    const weaponData = [ { name:'AK-47', mag:30, ammo:30, reserve:90, rate:0.095 }, { name:'Glock 19', mag:15, ammo:15, reserve:45, rate:0.14 }, { name:'Knife', mag:1, ammo:1, reserve:0, rate:0.45 } ];
    const hudWeaponName = document.getElementById('weaponName'); const hudAmmo = document.getElementById('ammo'); const hudReserve = document.getElementById('reserve');
    function updateHUD(){ const w = weaponData[activeWeapon]; hudWeaponName.textContent = w.name; hudAmmo.textContent = w.ammo; hudReserve.textContent = w.reserve; }
    updateHUD();

    // ---------- Raycast, Muzzle Flash ----------
    const raycaster = new THREE.Raycaster(); let lastShot = 0;
    function spawnMuzzleFlash(worldPos){ const geom = new THREE.PlaneGeometry(0.18,0.12); const mat = new THREE.MeshBasicMaterial({ color:0xfff0b6, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending }); const mesh = new THREE.Mesh(geom, mat); mesh.position.copy(worldPos); mesh.lookAt(camera.position); scene.add(mesh); setTimeout(()=>{ try{ scene.remove(mesh);}catch(e){} }, 80);
      // sparks
      for(let i=0;i<10;i++){ const s = new THREE.Mesh(new THREE.SphereGeometry(0.01,6,6), new THREE.MeshBasicMaterial({ color:0xffb86b })); s.position.copy(worldPos); s.velocity = new THREE.Vector3((Math.random()-0.5)*0.6, Math.random()*0.7, (Math.random()-0.5)*0.6); scene.add(s); (function(start){ const fn=(t)=>{ const tt=(t-start)/1000; s.position.addScaledVector(s.velocity,0.016); s.velocity.y -= 1.2*0.016; s.material.opacity = Math.max(0,1-tt*1.5); if(tt < 0.7) requestAnimationFrame(fn); else try{ scene.remove(s);}catch(e){} }; requestAnimationFrame((n)=>fn(n)); })(performance.now()); }
    }

    function fireWeapon(){ const now = performance.now()/1000; const wd = weaponData[activeWeapon]; if(now - lastShot < wd.rate) return; if(wd.ammo <= 0) return; lastShot = now; wd.ammo = Math.max(0, wd.ammo - 1); updateHUD(); const wMesh = weapons[activeWeapon]; if(wMesh.userData.anim) wMesh.userData.anim.recoil = 1.0;
      // raycast from camera forward
      const origin = new THREE.Vector3(); camera.getWorldPosition(origin);
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      raycaster.set(origin, dir);
      const hits = raycaster.intersectObjects(scene.children, true).filter(i=> !weapons.includes(i.object) && i.object !== hands && i.object !== leftArm && i.object !== rightArm && i.object !== floor);
      if(hits.length){ const h = hits[0].object; if(h.material && h.material.color) h.material.color.offsetHSL(0, -0.05, -0.04); }
      // muzzle flash at muzzle local position
      const muzzleLocal = new THREE.Vector3(0.95, 0, 0);
      const muzzleWorld = wMesh.localToWorld(muzzleLocal.clone());
      spawnMuzzleFlash(muzzleWorld);
    }

    // ---------- Input ----------
    const keys = { forward:false, backward:false, left:false, right:false };
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'KeyW') keys.forward = true;
      if(e.code === 'KeyS') keys.backward = true;
      if(e.code === 'KeyA') keys.left = true;
      if(e.code === 'KeyD') keys.right = true;
      if(e.key === '1') setActive(0);
      if(e.key === '2') setActive(1);
      if(e.key === '3') setActive(2);
      if(e.key === 'r' || e.key === 'R') reload();
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code === 'KeyW') keys.forward = false;
      if(e.code === 'KeyS') keys.backward = false;
      if(e.code === 'KeyA') keys.left = false;
      if(e.code === 'KeyD') keys.right = false;
    });

    window.addEventListener('mousedown', (e)=>{ if(e.button === 0) fireWeapon(); });

    function reload(){ const w = weaponData[activeWeapon]; if(w.reserve <= 0) return; const need = w.mag - w.ammo; const take = Math.min(need, w.reserve); w.ammo += take; w.reserve -= take; updateHUD(); }

    // ---------- Look handling: PointerLock + drag fallback ----------
    let pointerLocked = false;
    let plControls = null;
    if(THREE.PointerLockControls){ try{ plControls = new THREE.PointerLockControls(camera, renderer.domElement); plControls.addEventListener('lock', ()=>{ pointerLocked = true; startBtn.style.display = 'none'; infoText.textContent = 'Pointer locked — play!'; }); plControls.addEventListener('unlock', ()=>{ pointerLocked = false; startBtn.style.display = 'block'; infoText.textContent = 'Pointer unlocked — click to lock or drag to look.'; }); document.addEventListener('click', ()=>{ if(!pointerLocked) plControls.lock(); }); }catch(e){ console.warn('PointerLockControls init failed', e); }
    }

    // drag fallback when pointer not locked
    let dragging = false; let prev = { x:0, y:0 }; let yaw = 0, pitch = 0;
    renderer.domElement.addEventListener('mousedown', (e)=>{ dragging = true; prev.x = e.clientX; prev.y = e.clientY; });
    window.addEventListener('mouseup', ()=>{ dragging = false; });
    window.addEventListener('mousemove', (e)=>{
      if(pointerLocked) return; // pointerlock controls rotation
      if(!dragging) return;
      const dx = e.clientX - prev.x; const dy = e.clientY - prev.y; prev.x = e.clientX; prev.y = e.clientY;
      const sensitivity = 0.0025;
      yaw -= dx * sensitivity; pitch -= dy * sensitivity;
      pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
      camera.rotation.order = 'YXZ'; camera.rotation.y = yaw; camera.rotation.x = pitch;
    });

    // start button for user gesture
    startBtn.addEventListener('click', ()=>{ try{ if(plControls) plControls.lock(); startBtn.style.display = 'none'; }catch(e){ console.warn(e); } });

    // ---------- Movement logic (fixed direction) ----------
    const tempVec = new THREE.Vector3();
    function getPlayerObject(){ return (pointerLocked && plControls) ? plControls.getObject() : camera; }

    // ---------- Animation / main loop ----------
    let prevTime = performance.now();
    function animate(){ const now = performance.now(); const dt = Math.min((now - prevTime) / 1000, 0.05); prevTime = now;
      // movement
      const player = getPlayerObject();
      const forward = new THREE.Vector3(); player.getWorldDirection(forward); forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, player.up).normalize();
      const speed = 5;
      if(keys.forward) player.position.addScaledVector(forward, speed * dt);
      if(keys.backward) player.position.addScaledVector(forward, -speed * dt);
      if(keys.left) player.position.addScaledVector(right, -speed * dt);
      if(keys.right) player.position.addScaledVector(right, speed * dt);

      // weapon anims
      weapons.forEach(w=>{
        if(w.userData.anim){ for(const k in w.userData.anim) w.userData.anim[k] = Math.max(0, w.userData.anim[k] - dt * 6); const r = (w.userData.anim.recoil||0) * 0.035; w.position.z = -0.2 - r; w.rotation.x = -0.15 - (w.userData.anim.recoil||0) * 0.08; }
      });

      // hands bobbing to feel alive
      hands.position.y = -0.25 + Math.sin(now/180) * 0.006;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // remove startBtn after some time if pointer lock not required
    setTimeout(()=>{ try{ startBtn.style.display = 'none'; }catch(e){} }, 5000);

    // handle resize
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    console.log('FPS demo fixed: pointer lock enabled, movement direction corrected, Minecraft-like hands visible, lighting added.');
  })();
  </script>
</body>
</html>
