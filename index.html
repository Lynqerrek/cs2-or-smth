<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D FPS Demo — AK / Glock / Knife (Three.js)</title>
  <style>
    html,body{height:100%;margin:0;background:#000}
    canvas{display:block}
    .overlay{
      position:fixed;left:0;right:0;top:0;pointer-events:none;z-index:10;
      display:flex;justify-content:center;align-items:center;height:100%;
    }
    .crosshair{
      width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.9);
      pointer-events:none;transform:translate(-50%,-50%);position:relative;left:50%;top:50%;
      box-shadow:0 0 8px rgba(255,255,255,0.25);
    }
    .hud{
      position:fixed;left:12px;bottom:12px;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial;
      background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:6px;backdrop-filter:blur(3px);
      pointer-events:auto;z-index:20;font-size:13px;
    }
    .hint{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);color:#ddd;z-index:20;font-size:13px;background:rgba(0,0,0,0.25);padding:6px 10px;border-radius:6px}
    button.big{padding:8px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.03);color:#fff}
  </style>
</head>
<body>
  <div class="overlay"><div class="crosshair"></div></div>
  <div class="hud" id="hud">Weapon: <strong id="weaponName">AK-47</strong> • Ammo: <span id="ammo">30</span>/<span id="reserve">90</span></div>
  <div class="hint" id="hint">Click to lock pointer and start — 1 = AK | 2 = Glock | 3 = Knife — LMB to fire</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/PointerLockControls.js';

    // ---------- Basic scene ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ---------- Lights ----------
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 2);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    // ---------- Floor / environment ----------
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x556b2f });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // some boxes to shoot at
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
    for(let i=0;i<20;i++){
      const b = new THREE.Mesh(boxGeo, boxMat.clone());
      b.material.roughness = 0.7;
      b.position.set((Math.random()-0.5)*50,0.5,(Math.random()-0.5)*50 - 30);
      b.rotation.y = Math.random()*Math.PI*2;
      scene.add(b);
    }

    // ---------- Controls (pointer lock) ----------
    const controls = new PointerLockControls(camera, document.body);
    document.addEventListener('click', ()=>{
      controls.lock();
      document.getElementById('hint').style.display = 'none';
    }, {once:false});

    // simple WASD movement
    const move = { forward:false, backward:false, left:false, right:false };
    document.addEventListener('keydown', e=>{
      if(e.code==='KeyW') move.forward=true;
      if(e.code==='KeyS') move.backward=true;
      if(e.code==='KeyA') move.left=true;
      if(e.code==='KeyD') move.right=true;

      // weapon keys
      if(e.key === '1') switchWeapon(0);
      if(e.key === '2') switchWeapon(1);
      if(e.key === '3') switchWeapon(2);
    });
    document.addEventListener('keyup', e=>{
      if(e.code==='KeyW') move.forward=false;
      if(e.code==='KeyS') move.backward=false;
      if(e.code==='KeyA') move.left=false;
      if(e.code==='KeyD') move.right=false;
    });

    // ---------- Player hands + weapon container ----------
    // We'll attach a group to the camera so it moves with the camera.
    const hands = new THREE.Group();
    camera.add(hands);
    scene.add(camera);

    // position hands in front of the camera (like in FPS)
    hands.position.set(0,-0.25,-0.45);

    // helper to create a simple "hand".
    function makeHand(side = 'left'){
      const g = new THREE.Group();
      const palm = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.08,0.24), new THREE.MeshStandardMaterial({color:0xffd1a4}));
      palm.position.set(side==='left'?-0.12:0.12, -0.05, -0.12);
      g.add(palm);
      return g;
    }

    // build three weapons as simple geometry models
    function makeAK(){
      const g = new THREE.Group();
      // body
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.12,0.12), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
      body.position.set(0.1,-0.02,0);
      g.add(body);
      // stock
      const stock = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.1,0.12), new THREE.MeshStandardMaterial({color:0x4b2b1f}));
      stock.position.set(-0.6,0,-0.02);
      g.add(stock);
      // barrel
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.9,8), new THREE.MeshStandardMaterial({color:0x111111}));
      barrel.rotation.z = Math.PI/2;
      barrel.position.set(0.7,-0.02,0);
      g.add(barrel);
      // magazine
      const mag = new THREE.Mesh(new THREE.BoxGeometry(0.16,0.36,0.06), new THREE.MeshStandardMaterial({color:0x111111}));
      mag.position.set(0.02,-0.2,0);
      mag.rotation.z = 0.15;
      g.add(mag);
      g.name = 'AK-47';
      g.scale.set(0.9,0.9,0.9);
      return g;
    }

    function makeGlock(){
      const g = new THREE.Group();
      const slide = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.08,0.12), new THREE.MeshStandardMaterial({color:0x222222}));
      slide.position.set(0.15,-0.02,0);
      g.add(slide);
      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.32,0.08), new THREE.MeshStandardMaterial({color:0x111111}));
      grip.position.set(-0.12,-0.18,0);
      grip.rotation.z = -0.06;
      g.add(grip);
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.35,8), new THREE.MeshStandardMaterial({color:0x111111}));
      barrel.rotation.z = Math.PI/2;
      barrel.position.set(0.4,-0.02,0);
      g.add(barrel);
      g.name = 'Glock 19';
      g.scale.set(1.1,1.1,1.1);
      return g;
    }

    function makeKnife(){
      const g = new THREE.Group();
      const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02,0.3,0.02), new THREE.MeshStandardMaterial({color:0xc0c0c0}));
      blade.position.set(0.25,-0.05,0);
      blade.rotation.z = 0.25;
      g.add(blade);
      const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.09,0.05), new THREE.MeshStandardMaterial({color:0x221711}));
      handle.position.set(-0.02,-0.12,0);
      g.add(handle);
      g.name = 'Knife';
      g.scale.set(1.6,1.6,1.6);
      return g;
    }

    // add hands
    const leftHand = makeHand('left');
    const rightHand = makeHand('right');
    hands.add(leftHand);
    hands.add(rightHand);

    // attach weapons to hands group (positioned so they appear as held)
    const weapons = [makeAK(), makeGlock(), makeKnife()];
    weapons.forEach((w,i)=>{
      w.position.set(0,0,0);
      w.visible = false;
      // place them a bit to the right so they look like in front of the camera
      w.position.set(0.25, -0.12, -0.2);
      w.rotation.set(-0.15, 0.2, 0);
      hands.add(w);
    });

    // initial active weapon
    let activeWeapon = 0;
    weapons[activeWeapon].visible = true;
    const hudWeaponName = document.getElementById('weaponName');
    const hudAmmo = document.getElementById('ammo');
    const hudReserve = document.getElementById('reserve');

    // ammo per weapon (simple)
    const weaponData = [
      {name:'AK-47', ammo:30, mag:30, reserve:90, fireRate: 0.12},
      {name:'Glock 19', ammo:15, mag:15, reserve:45, fireRate: 0.18},
      {name:'Knife', ammo:1, mag:1, reserve:0, fireRate:0.5}
    ];

    function updateHUD(){
      hudWeaponName.textContent = weaponData[activeWeapon].name;
      hudAmmo.textContent = weaponData[activeWeapon].ammo;
      hudReserve.textContent = weaponData[activeWeapon].reserve;
    }
    updateHUD();

    // ---------- Weapon switching with animation ----------
    let switching = false;
    function switchWeapon(index){
      if(index === activeWeapon || switching) return;
      switching = true;
      const old = weapons[activeWeapon];
      const nw = weapons[index];
      // animate old moving down/out
      const tDur = 200; // ms
      const start = performance.now();
      const fromPos = old.position.clone();
      const toPos = fromPos.clone().add(new THREE.Vector3(0, -0.4, 0.2));
      const fromRot = old.rotation.clone();
      const toRot = fromRot.clone().add(new THREE.Euler(0.6, -0.6, 0.3));

      nw.visible = true;
      // set incoming start (off-screen)
      nw.position.set(fromPos.x, fromPos.y - 0.4, fromPos.z + 0.2);
      nw.rotation.set(fromRot.x + 0.6, fromRot.y - 0.6, fromRot.z + 0.3);

      function animSwitch(now){
        const dt = Math.min((now - start) / tDur, 1);
        // old moves out
        old.position.lerpVectors(fromPos, toPos, dt);
        old.rotation.x = THREE.MathUtils.lerp(fromRot.x, toRot.x, dt);
        old.rotation.y = THREE.MathUtils.lerp(fromRot.y, toRot.y, dt);
        old.rotation.z = THREE.MathUtils.lerp(fromRot.z, toRot.z, dt);
        // new moves in
        nw.position.lerpVectors(new THREE.Vector3(fromPos.x, fromPos.y - 0.4, fromPos.z + 0.2), fromPos, dt);
        nw.rotation.x = THREE.MathUtils.lerp(fromRot.x + 0.6, fromRot.x, dt);
        nw.rotation.y = THREE.MathUtils.lerp(fromRot.y - 0.6, fromRot.y, dt);
        nw.rotation.z = THREE.MathUtils.lerp(fromRot.z + 0.3, fromRot.z, dt);

        if(dt < 1){
          requestAnimationFrame(animSwitch);
        } else {
          old.visible = false;
          activeWeapon = index;
          switching = false;
          updateHUD();
        }
      }
      requestAnimationFrame(animSwitch);
    }

    // ---------- Shooting logic (raycast) ----------
    const raycaster = new THREE.Raycaster();
    let lastShotTime = 0;

    function fireWeapon(){
      const now = performance.now() / 1000;
      const w = weaponData[activeWeapon];
      if(now - lastShotTime < w.fireRate) return; // rate limit
      if(w.ammo <= 0){
        // click empty
        // TODO: reload
        return;
      }
      lastShotTime = now;

      // muzzle / recoil effect: brief backward translation and rotation
      const weaponMesh = weapons[activeWeapon];
      const recoilStart = performance.now();
      const recoilDur = 80;
      const origPos = weaponMesh.position.clone();
      const origRot = weaponMesh.rotation.clone();
      const recoilOffset = new THREE.Vector3(0,0.03,0.05);
      const recoilRot = origRot.clone().add(new THREE.Euler(-0.05,0,0));

      (function doRecoil(now){
        const dt = Math.min((now - recoilStart) / recoilDur, 1);
        // push back quickly then return
        const ease = dt < 0.5 ? dt*2 : 2 - dt*2;
        weaponMesh.position.lerpVectors(origPos, origPos.clone().add(recoilOffset), ease);
        weaponMesh.rotation.x = THREE.MathUtils.lerp(origRot.x, recoilRot.x, ease);
        if(dt < 1) requestAnimationFrame(doRecoil);
        else { weaponMesh.position.copy(origPos); weaponMesh.rotation.copy(origRot); }
      })(performance.now());

      // decrease ammo
      w.ammo = Math.max(0, w.ammo - 1);
      updateHUD();

      // do a raycast from camera
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      raycaster.set(camera.getWorldPosition(new THREE.Vector3()), dir);
      const hit = raycaster.intersectObjects(scene.children, true).find(i => i.object !== weapons[0] && i.object !== weapons[1] && i.object !== weapons[2] && i.object !== leftHand && i.object !== rightHand && i.object !== floor);
      if(hit){
        // simple effect: darken target and scale
        const obj = hit.object;
        if(obj.material && obj.material.color){
          obj.material.color.offsetHSL(0,0,-0.15);
        }
        obj.scale.multiplyScalar(0.98);
      }

      // small flash sprite
      const flash = new THREE.Mesh(new THREE.SphereGeometry(0.06,8,8), new THREE.MeshBasicMaterial({color:0xfff0b6}));
      const muzzlePos = weaponMesh.localToWorld(new THREE.Vector3(0.9,0,0));
      flash.position.copy(muzzlePos);
      scene.add(flash);
      setTimeout(()=>scene.remove(flash), 80);
    }

    window.addEventListener('mousedown', (e)=>{
      if(e.button === 0) fireWeapon();
    });

    // ---------- Simple reload (R) ----------
    document.addEventListener('keydown', e=>{
      if(e.key.toLowerCase() === 'r') reload();
    });
    function reload(){
      const w = weaponData[activeWeapon];
      if(w.reserve <= 0) return;
      const need = w.mag - w.ammo;
      const take = Math.min(need, w.reserve);
      w.ammo += take;
      w.reserve -= take;
      updateHUD();
    }

    // ---------- Resize ----------
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ---------- Main loop ----------
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const speed = 5; // m/s
    let prevTime = performance.now();

    function animate(){
      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      // movement
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      direction.z = Number(move.forward) - Number(move.backward);
      direction.x = Number(move.right) - Number(move.left);
      direction.normalize();

      if(move.forward || move.backward) velocity.z -= direction.z * speed * delta;
      if(move.left || move.right) velocity.x -= direction.x * speed * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);

      // simple bobbing for hands
      const t = time / 200;
      hands.position.y = -0.25 + Math.sin(t) * 0.005;
      hands.rotation.x = Math.sin(t*0.5) * 0.002;

      renderer.render(scene, camera);
      prevTime = time;
      requestAnimationFrame(animate);
    }
    animate();

    // ---------- Helpful notes for extending to multiplayer ----------
    // This demo is single-player and local. For multiplayer you would:
    // - Send player position + rotation + activeWeapon to the server
    // - Each client would render remote players as separate Character meshes
    // - Keep meshes for other players with their own weapon groups (same models)
    // - Reconcile latency via interpolation/extrapolation
    // Consider using WebRTC / WebSockets + a lightweight authoritative server.

  </script>
</body>
</html>
